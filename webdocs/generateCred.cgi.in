#!@PERL@ @PERL_CGI_BIN_ARGS@
######################################################################
#
# $Id$
#
# This script is invoked by the Java Web Start CredentialRetriever
# application. It comsumes the token created by the "login" script,
# contacts MyProxy to generate a X509 credential and returns that
# credential to CredentialRetriever.
#
######################################################################
# Copyright 2006 The Board of Trustees of the University of Illinois.
# All rights reserved.

# Developed by:

#   The GridShib Project
#   National Center for Supercomputing Applications
#   University of Illinois
#   http://gridshib.globus.org/

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal with the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

#   Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimers.

#   Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimers in the
#   documentation and/or other materials provided with the distribution.

#   Neither the names of the National Center for Supercomputing
#   Applications, the University of Illinois, nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this Software without specific prior written permission.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.
######################################################################

use GridShibCA::Config;

use Crypt::OpenSSL::X509;

# Run safely
$ENV{PATH} = "/bin";
umask (0077);

######################################################################
#
# Initialize config instance, logger and errorHandler
#

my $config = GridShibCA::Config->new();

$logger = $config->getLogger();

if (!defined($logger))
{
    # No good way to report this
    die "Could not initialize Logger: " . $config->getError();
}

my $errorHandler = $config->getHTMLError();

if (!defined($errorHandler))
{
    $logger->err("Failed to load HTMLError module: " . $config->getError());
    die "Failed to load HTMLError module: " . $config->getError();
}

######################################################################

$cgi = $config->getCGI();

if (!defined($cgi))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_INTERNAL_ERROR,
				 "Could not initialize CGI interface: %s",
				 $config->getError());
}

my $shib = $config->getShibInterface();

if (!defined($shib))
{
    errorExit($HTTP_INTERNAL_ERROR,
	      "Could not initialize Shib interface: "
	      . $config->getError());
}

# scope these variables to package for use in errorExit
$user = $shib->getUserId();
$idp = $shib->getIdP();
$remoteAddr = $cgi->remote_host();

if (!defined($user))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_UNAUTHORIZED,
				 "REMOTE_USER not defined.");
}

if (!defined($remoteAddr))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_INTERNAL_ERROR,
				 "REMOTE_ADDR not defined.");
}

if (!defined($idp))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_INTERNAL_ERROR, 
				 "Could not determine Shibboleth identity provider for user");
}

$logger->info("CONNECTION:%s:%s:\"%s\"", $user, $remoteAddr, $idp);

######################################################################
#
# Get POST data
#

my $certificateRequest = $cgi->getCertificateRequest();

if (!defined($certificateRequest))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_BAD_REQUEST,
				 "Certificate request missing");
}
if ($certificateRequest eq "")
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_BAD_REQUEST,
				 "Certificate request empty");
}

my $token = $cgi->getToken();

if (!defined($token))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_BAD_REQUEST,
				 "Token missing from request");
}

my $portalURL = $cgi->getPortalURL();

my $requestedLifetime = $cgi->getRequestedCredLifetime();

######################################################################
#
# Validate token
#
# This ensures that this request was routed here through a trusted
# CGI script and not, e.g., malicious javascript.

my $session = $config->getCGISession();

if (!defined($session))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_INTERNAL_ERROR,
				 "Could not initialize token generator: %s",
				 $config->getError());
}

# token is our session id
if (!$session->fromId($token))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_BAD_REQUEST,
				 "Error verifying token: %s",
				 $tokenGenerator->getError());
}

if ($session->param("userId") ne $user)
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_BAD_REQUEST,
				 "User Id in session (%s) does not match actual (%s)",
		 $$session->param("userId"), $user);
}

# We're done with the session, we only use it once, delete it.
$session->destroy();

######################################################################
#
# Authorize request
#

my $authorization = $config->getAuthorization();

if (!$authorization->authorizeUser($user, $idp))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_UNAUTHORIZED,
				 "Authorization failed: User %s (Idp %s): %s",
				 $user, $idp, $authorization->getError());
}

if (defined($portalURL))
{
    if (!$config->getParamBoolean("allowPortalDelegation"))
    {
	$errorHandler->HTTPErrorExit($errorHandler->HTTP_UNAUTHORIZED,
				     "Portal delegation disabled.");
    }

    if (!$authorization->authorizePortal($portalURL))
    {
	$errorHandler->HTTPErrorExit($errorHandler->HTTP_UNAUTHORIZED,
				     "Authorization failed: Portal (%s) not authorized: %s",
				     $portalURL, $authorization->getError());
    }
}

######################################################################
#
# And generate the credentials, which will be written to stdout.
#

my $ca = $config->getCA($user, $idp);
if (!defined($ca))
{
    errorExit($HTTP_INTERNAL_ERROR,
	      "Could not instantiate CA interface "
	      . $config->getError());
}

if ($requestedLifetime)
{
    $logger->debug("Requesting lifetime of %d", $requestedLifetime);
    if (!$ca->setCredLifetime($requestedLifetime))
    {
	$errorHandler->HTTPErrorExit($errorHandler->HTTP_UNAUTHORIZED,
				     "Error with requested lifetime: %s",
				     $ca->getError());
    }
}

my $certificate = $ca->signRequest($certificateRequest);

if (!defined($certificate))
{
    $errorHandler->HTTPErrorExit($errorHandler->HTTP_INTERNAL_ERROR,
				 "Error signing certificate request: %s",
				 $ca->getError());
}

my $x509 = Crypt::OpenSSL::X509->new_from_string($certificate);
if (!defined($x509))
{
    # Not clear to me how Crypt::OpenSSL::X509 returns an error string
    errorExit($HTTP_INTERNAL_ERROR,
	      "Error parsing certificate");
}

my $DN = $x509->subject();
my $serial = $x509->serial();
my $hash = $x509->hash();

$logger->info("ISSUE: user=%s idp=%s remoteAddr=%s serial=\"%s\" hash=%s DN=\"%s\" lifetime=%d",
	      $user, $idp, $remoteAddr, $serial, $hash,
	      $DN, $ca->getCredLifetime());

my $certRegistry = $config->getCertRegistry();

if (defined($certRegistry))
{
    $logger->debug("Calling certificate registry.");
    if (!$certRegistry->registerCert($user,
				     $idp,
				     $DN,
				     $certificate,
				     $ca->getCredLifetime()))
    {
	$errorHandler->HTTPErrorExit($errorHandler->HTTP_INTERNAL_ERROR,
				     "Error registering certificate: %s",
				     $certRegistry->getError());
    }
}

# Success, output credential

if (!defined($portalURL))
{
    # No portal URL, we are outputing to simple client as text
    print $cgi->header("text/plain");
    print $certificate;
}
else
{
    # Output form to allow certificate to be posted to a portal
    my $portalData = $cgi->getPortalData();


    my $template = $config->getHTMLTemplate("portal-output.html");

    if (!defined($template))
    {
	$errorHandler->HTMLErrorExit(GridShibCA::HTMLTemplate::getError());
    }

    $template->addMappings({
	Certificate => $certificate,
	PortalData => $portalData,
	PortalURL => $portalURL
			   });

    my $html = $template->getHTML();

    if (!defined($html))
    {
	$errorHandler->HTMLErrorExit($template->getError());
    }

    print $html;

}

######################################################################
#
# And we're done
#

exit(0);

### Local Variables: ***
### mode:perl ***
### End: ***
