######################################################################
#
# This file is part of the GriShib-CA distribution.  Copyright
# 2006-2009 The Board of Trustees of the University of
# Illinois. Please see LICENSE at the root of the distribution.
#
######################################################################

=head1 GridShibCA::OpenIdLogon

Authenticate the user via OpenId. Note that this takes a round trip
between this application and the user's identity provider, meaning
this module will be invoked multiple times.

=cut

package GridShibCA::OpenIdLogon;

# Inherit Logon
use base qw(GridShibCA::Logon);

use FileHandle;
use GridShibCA::Exception qw(:try);
use GridShibCA::UserIdentity;
use LWP::UserAgent;
use Net::OpenID::Consumer;

=head2 Methods

=over 4

=item doCommand()

Override base class with my specific logic.

B<Arguments:> None

B<Returns:> True on success, False on error.

=cut

sub doCommand
{
    my $self = shift;

    my $cgi = $self->{cgi};
    my $myURL = $cgi->url(-full => 1);
    my $baseURL = $cgi->url(-base => 1);
    my $secret = $self->_getConsumerSecret();

    my $consumer = Net::OpenID::Consumer->new(
	# The user agent which sends the openid off to the server.
	ua => LWP::UserAgent->new(),
	# Require base for return URL
	required_root => $baseURL,
	# Our secret for nonces
	consumer_secret => $secret,
	# Way for Consumer to get at CGI parameters
	args => $cgi,
	);

    # I would use handle_server_response here if there was some way to 
    # pass $self to the callbacks.
    if ($consumer->is_server_response())
    {
	my $setup_url = $consumer->user_setup_url();
	my $verifiedId = $consumer->verified_identity();
	if ($setup_url)
	{
	    $self->{logger}->debug("OpenId setup required. Redirecting user to $setup_url");
	    $self->_redirect($setup_url);
	}
	elsif ($consumer->user_cancel())
	{
	    $self->{logger}->debug("User canceled OpenId authentication.");
	    $self->displayHTML("OpenIdCancel");
	}
	elsif ($verifiedId)
	{
	    $self->{logger}->debug("OpenId authentication successful: " .
		$verifiedId->url());
	    my $id = GridShibCA::UserIdentity->new(
		-authMethod => "OpenId",
		-clientHost => $self->getClientHost(),
		-userId => $verifiedId->url(),
		-idpId => $verifiedId->url());

	    my $session = $self->_doLogon($id);
	    $self->_displayHTML("OpenIdSuccess", %mappings);
	}
	else
	{
	    throw GridShibCA::OpenIdException($consumer);
	}
    }
    else
    {
	# Not an OpenId response. In this case we either need to
	# present the user with a login form, or process the result of
	# that login form. Look for an openid parameter - if present,
	# then this is the form submission. Otherwise we output the
	# form.
	my $openid = $self->{cgi}->param("openid");
	if ($openid)
	{
	    $self->{logger}->debug("Got claimed OpenId: $openid");
	    my $claimedId = $consumer->claimed_identity($openid);
	    if (!$claimedId)
	    {
		throw GridShibCA::OpenIdException($consumer);
	    }
	    $self->{logger}->debug("Redirecting user to OpenId provider.");
	    my $checkURL = $claimedId->check_url (
		# The place we go back to.
		return_to  => $myURL,
		# Having this simplifies the login process.
		trust_root => $baseURL,
		);
	    $self->_redirect($checkURL);
	}
	else
	{
	    # Output logon form
	    $self->{logger}->debug("Providing user OpenId logon form.");
	    $self->_displayHTML("OpenIdLogonForm");
	}
    }

# XXX Add error handling
#	    my %mappings = ();
#	    $mappings{errcode} = $consumer->errcode();
#	    $mappings{errtext} = $consumer->errtext();
#	    $self->_displayHTML("OpenIdError", %mappings);

    return 1;
}


=item _requirements()

Return protection requirements of this command.

B<Arguments:> None

B<Returns:> Requirements value

=cut

sub _requirements
{
    return $GridShibCA::WebCommand::REQUIRE_HTTPS;
}

=item _getConsumerSecret()

Return static consumer secret

B<Arguments:> None

B<Returns:> Consumer secret as string

=cut

sub _getConsumerSecret
{
    my $self = shift;
    my $secretFilename = $self->{config}->getParam("OpenId",
						   "ConsumerSecretFilename");
    if (! -f $secretFilename )
    {
	throw GridShibCA::OpenIdException("OpenId Consumer secret file does not exist: $secretFilename");
    }

    if (! -r $secretFilename )
    {
	throw GridShibCA::OpenIdException("OpenId Consumer secret file is not readable: $secretFilename");
    }

    $self->{logger}->debug("Reading OpenId consumer secret from $secretFilename");

    my $file = FileHandle->new($secretFilename, "r") ||
	throw GridShibCA::OpenIdException("Error opening OpenId Consumer secret file $secretFilename: $!");

    my $secret = $file->getline() ||
	throw GridShibCA::OpenIdException("Error reading OpenId Consumer secret from $secretFilename: $!");

    $self->{logger}->debug("Reading OpenId consumer secret is $secret");

    $file->close();

    return $secret;
}

=back

=cut

######################################################################
#
# GridShibCA::OpenIdException

package GridShibCA::OpenIdException;

# Inherit GridShibCA::Exception
use base qw(GridShibCA::Exception);

=head1 GridShibCA::OpenIdException

Class for exceptions caused by session errors.

=over 4

=item new()

B<Arguments:> Net::OpenID::Consumer instance or string.

B<Returns:> GridShibCA::OpenIdException instance.

=cut

sub new
{
    my $class = shift;
    my $text = shift;

    if (ref($test))
    {
	# Net::OpenId::Consumer instance
	my $errcode = $text->errcode();
	my $errtext = $text->errtext();
	$text = "OpenId error: $errtext ($errcode)";
    }

    my $self = $class->SUPER::new($text);
    bless($self, $class);
    $self->{errcode} = $errcode;
    $self->{errtext} = $errtext;
    return $self;
}

=back

=cut 

######################################################################

=head2 Version

GridShib-CA version @PACKAGE_VERSION_STRING@

=cut

# Return true for import/use
1;

######################################################################
### Local Variables: ***
### mode:perl ***
### End: ***
