######################################################################
#
# $Id$
#
# GridShib configuration and class loader.
#
######################################################################
# Copyright 2006 The Board of Trustees of the University of Illinois.
# All rights reserved.

# Developed by:

#   The GridShib Project
#   National Center for Supercomputing Applications
#   University of Illinois
#   http://gridshib.globus.org/

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal with the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

#   Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimers.

#   Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimers in the
#   documentation and/or other materials provided with the distribution.

#   Neither the names of the National Center for Supercomputing
#   Applications, the University of Illinois, nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this Software without specific prior written permission.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.
######################################################################

=head1 GridShibCA::Config

Interface to GridShib CA configuration and loader of classes based
on that configuration.

=cut

package GridShibCA::Config;

use GridShibCA::Constants;

use Carp;
use Config::General;

# Configuration file to read
my $configFilename = $GridShibCA::Constants::CONFIG_FILE;

# Actual Config::General object, will be set first time Config object is created
my $config = undef;

=head2 Methods

=over 4

=item new()

Create a new Config object.

B<Arguments:>

C<$debug> Turn on debugging if True

C<$defaultSection> Section to use for getParam() requests.

B<Returns:> Config instance

=cut

sub new
{
    my $class = shift;
    my %args = @_;

    my $self = {};
    bless($self, $class);

    if (defined($args{debug}) && $args{debug})
    {
	$self->{debug} = 1;
	$self->_debug("Debugging enabled");
    }

    $self->{defaultSection} = undef;
    if (defined($args{defaultSection}))
    {
	$self->{defaultSection} = $args{defaultSection};
    }

    # Maximum number of replacements on configuration variables
    $self->{replacementLimit} = 24;
    # Error string
    $self->{error} = undef;

    if (!defined($config))
    {
	$self->_initConfig();
    }
    $self->{config} = $config;

    return $self;
}

=item getConfigFilename()

Return the filename of the configuration file.

B<Arguments:> None.

B<Returns:> Filename as string.

=cut

sub getConfigFilename
{
    return $configFilename;
}


=item setConfigFilename()

Set filename of the configuration file.

B<Arguments:> Filename as string

B<Returns:> Nothing.

=cut

sub setConfigFilename
{
    my $class = shift;
    my $filename = shift;
    $configFilename = $filename;
}

=item getParam()

Return a configuration parameter from the default section.

B<Arguments:>
 Parameter name as string

B<Returns:>
Value as string, undef if not defined

=cut

sub getParam
{
    my $self = shift;
    my $param = shift;
    my $section = $self->{defaultSection};

    return $self->getSectionParam($section, $param);
}

=item getParamBoolean()

Return a boolean configuration parameter from the default section.

B<Arguments:>
 Parameter name as string

B<Returns:>
Value as boolean, undef if not defined or not boolean.

=cut

sub getParamBoolean
{
    my $self = shift;
    my $param = shift;

    # Config::General handles this for us, so we just use normal method
    return $self->getParam($param);
}

=item getSectionParam()

Return a configuration parameter from the given section.

B<Arguments:>

C<$section> Section name as string.

C<$param> Parameter name as string.

B<Returns:>
Value as string, undef if not defined

=cut

sub getSectionParam
{
    my $self = shift;
    my $section = shift;
    my $param = shift;

    my $config = $self->{config};

    if (defined($section))
    {
	if (!$config->exists($section) ||
	    !$config->is_hash($section))
	{
	    $self->_error("Request for parameter \"%s\" in non-existant section \"%s\"",
			  $param, $section);
	    return undef;
	}

	# Section now becomes the object we get value from.
	$config = $config->obj($section);
    }
    if (!$config->exists($param))
    {
	my $string = sprintf("Unknown parameter \"%s\"", $param);
	if (defined($section))
	{
	    $string .= sprintf(" in section \"%s\"", $section);
	}
	$self->_error($string);
	return undef;
    }	

    my $value = $config->value($param);
    return $value;
}

=item dump()

Print parameters to STDOUT. Intended for debugging.

B<Arguments:> None

B<Returns:> Nothing

=cut

sub dump
{
    my $self = shift;
    my $config = $self->{config};

    for $key ($config->keys())
    {
	print $key . "=\"" . $self->getParam($key) . "\"\n";
    }
}

=item getError()

Return the last error message as a string.

B<Arguments:> None

B<Returns:> Nothing

=cut

sub getError
{
    my $self = shift;
    return $self->{error};
}


=item  getCommandClass()

Given a command name, return the name of the Command class referenced
by that name from the Commands section of the configuration file.

B<Arguments:>

C<$request> Request instance.

B<Returns:> Instance, undef on error.

=cut

sub getCommandClass
{
    my $self = shift;
    my $request = shift;

    my $command = $request->getCommand();
    if (!defined($command))
    {
	$self->_error("Failed to parse command from request: %s",
		      $request->getError());
	return undef;
    }

    my $className = $self->getSectionParam("Commands", $command);
    if (!defined($className))
    {
	$self->_error("Unrecognized command \"%s\"", $command);
	return undef;
    }
    return $className;
}

=back

=cut

######################################################################

=head2 Module Loading Methods

These functions fetch instances of Modules bases on configuration.
Each returns an instance of the given Module or a derived Module
which implements the same interface.

=over 4

=item getModules()

Return a list of all modules configured in F<gridshib-ca.conf>. Mainly
intended for testing.

=cut
sub getModules
{
    my $self = shift;
    my $config = $self->{config};
    if (!$config->exists("Modules") || !$config->is_hash("Modules"))
    {
	return ();
    }
    my %modulesSection = $config->hash("Modules");
    return keys(%modulesSection);
}

=item getAuthorization()

Get an instance of the GridShibCA::Authorization module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::Authorization>.

The exact module loaded is controlled by the Authorization variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getAuthorization
{
    my $self = shift;
    return $self->_newModule("Authorization", @_);
}

=item getCA()

Get an instance of the GridShibCA::CA module by loading it and
calling its new method with the given arguments. See L<GridShibCA::CA>.

The exact module loaded is controlled by the CA variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getCA
{
    my $self = shift;
    return $self->_newModule("CA", @_);
}

=item getCertRegistry()

Get an instance of the GridShibCA::CertRegistry module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::CertRegistry>.

The exact module loaded is controlled by the CertRegistry variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getCertRegistry
{
    my $self = shift;
    return $self->_newModule("CertRegistry", @_);
}

=item getCGI()

Get an instance of the GridShibCA::CGI module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::CGIinterface>.

The exact module loaded is controlled by the CGI variable
in the Modules section F<gridshib-ca.conf>.

=cut

sub getCGI
{
    my $self = shift;
    return $self->_newModule("CGI", @_);
}

=item getCGISession()

Get an instance of the GridShibCA::CGISession module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::CGISession>.

The exact module loaded is controlled by the CGISession variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getCGISession
{
    my $self = shift;
    return $self->_newModule("CGISession", @_);
}


=item getCommand()

Get an instance of the GridShibCA::Command module by loading it and
calling its new method with the given arguments. See L<GridShibCA::Command>.

The exact module loaded is controlled by the Command variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getCommand
{
    my $self = shift;
    return $self->_newModule("Command", @_);
}

=item getHTMLError()

Get an instance of the GridShibCA::Error module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::HTMLError>.

The exact module loaded is controlled by the HTMLError variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getHTMLError
{
    my $self = shift;
    return $self->_newModule("HTMLError", @_);
}

=item getHTMLTemplate()

Get an instance of the GridShibCA::HTMLTemplate module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::HTMLTemplate>.

The exact module loaded is controlled by the HTMLTemplate variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getHTMLTemplate
{
    my $self = shift;
    return $self->_newModule("HTMLTemplate", @_);
}

=item getLogger()

Get an instance of the GridShibCA::Logger module by loading it and
calling its new method with the given arguments. See L<GridShibCA::Logger>.

The exact module loaded is controlled by the Logger variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getLogger
{
    my $self = shift;
    return $self->_newModule("Logger", @_);
}

=item getNameMapper()

Get an instance of the GridShibCA::NameMapper module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::NameMapper>.

The exact module loaded is controlled by the NameMapper variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getNameMapper
{
    my $self = shift;
    return $self->_newModule("NameMapper", @_);
}


=item getRequest()

Get an instance of the GridShibCA::Request module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::Request>.

The exact module loaded is controlled by the Request variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getRequest
{
    my $self = shift;
    return $self->_newModule("Request", @_);
}

=item getSAMLExtension()

Get an instance of the GridShibCA::SAMLExtension module by loading it
and calling its new method with the given arguments.  See
L<GridShibCA::SAMLExtension>.

The exact module loaded is controlled by the SAMLExtension variable
in F<gridshib-ca.conf>.

=cut

sub getSAMLExtension
{
    my $self = shift;
    return $self->_newModule("SAMLExtension", @_);
}

=item getTemplate()

Get an instance of the GridShibCA::Template module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::Template>.

The exact module loaded is controlled by the Template variable
in the Modules section of F<gridshib-ca.conf>.

=cut

sub getTemplate
{
    my $self = shift;
    return $self->_newModule("Template", @_);
}

=item getTokenGenerator()

Get an instance of the GridShibCA::TokenGenerator module by loading it and
calling its new method with the given arguments.
See L<GridShibCA::TokenGenerator>.

The exact module loaded is controlled by the TokenGenerator variable
in the modules section of F<gridshib-ca.conf>.

=cut

sub getTokenGenerator
{
    my $self = shift;
    return $self->_newModule("TokenGenerator", @_);
}

=item getWebSignOn()

Get an instance of the GridShibCA::WebSignOn module by loading it
and calling its new method with the given arguments.
See L<GridShibCA::WebSignOn>.

The exact module loaded is controlled by the WebSignOn variable in the
Modules section of F<gridshib-ca.conf>.

=cut

sub getWebSignOn
{
    my $self = shift;
    return $self->_newModule("WebSignOn", @_);
}

=back

=cut

######################################################################

=head2 Internal methods

These internal methods not intended for external use.

=over 4

=item  _initConfig()

Initialize our configuration the first time we are called.

B<Arguments:> None

B<Returns:> Instance, dies on error

=cut

sub _initConfig
{
    my $self = shift;
    $self->_debug("Initializing configuration from %s", $configFilename);
    my %options = (
	-ConfigFile => $configFilename,
	# Allow for variable substitution in values
	-InterPolateVars => 1,
	# Allow for OO type access to values
	-ExtendedAccess => 1,
	# Automatically parse booleans
	-AutoTrue => 1,
	# Allow for running under taint mode
	-AutoLaunder => 1,
	);
    if ($self->{debug})
    {
	# Complain about duplicates values
	$options{"-AllowMultiOptions"} = 0;
    }
    else
    {
	# Just use last option given
	$options{"-MergeDuplicateOptions"} = 1;
    }
    $config = new Config::General(%options);
    if (!defined($config))
    {
	$self->_error("Failed to parse configuration file %s",
		      $configFilename);
	exit(1);
    }
    # Make sure we recognize the configuration version number
    if (!$config->exists("ConfigVersion"))
    {
	$self->_error("Missing 'ConfigVersion' parameter in configuration file (%s): Old style configuration?",
		      $configFilename);
	exit(1);
    }
    else
    {
	my $configVersion = $config->value("ConfigVersion");
	if ($configVersion != 2)
	{
	    $self->_error("Unrecognized ConfigVersion (%s) in configuration file (%s).",
			  $config->{ConfigVersion}, $configFilename);
	    exit(1);
	}
    }
}


=item  _newModule()

Given a configuration variable name, return an instance of the
module referenced by that variable name.

B<Arguments:>

C<$class> Name of configuration variable

C<@_> Arguments to pass to new() method

B<Returns:> Instance, dies on error

=cut

sub _newModule
{
    my $self = shift;
    my $configVariable = shift;

    my $className = $self->getSectionParam("Modules", $configVariable);
    if (!defined($className))
    {
	$self->_error("Undefined module \"%s\"", $configVariable);
	return undef;
    }
    return $self->_newInstance($className, @_);
}


=item  _newInstance()

Create a new instance of the given class

B<Arguments:>

C<$class> Name of class to create

C<@_> Arguments to pass to new() method

B<Returns:> Instance, dies on error

=cut

sub _newInstance
{
    my $self = shift;
    my $class = shift;
    if (!defined($class))
    {
	$self->_error("\$class undefined");
	exit(1);
    }
    my @args = @_;

    my $instance = undef;
    eval "use $class; \$instance = $class->new(\@args);";
    if ($@)
    {
	$self->_error("Failure loading class $class: " . $@);
	exit(1);
    }
    if (!defined($instance))
    {
	$self->_error("Failure loading class $class: No instance returned.");
	exit(1);
    }
    return $instance;
}

=item _debug()

Handle a debug message. Does nothing if we're not in debugging mode.

B<Arguments:> As to sprintf()

B<Returns:> Nothing

=cut

sub _debug
{
    my $self = shift;

    if ($self->{debug})
    {
	my $format = shift;
	my @args = @_;
	chomp($format);
	print sprintf($format, @_) . "\n";
    }
}


=item _error()

Handle a error message.

B<Arguments:> As to sprintf()

B<Returns:> Nothing

=cut

sub _error
{
    my $self = shift;
    my $format = shift;
    if (!defined($format))
    {
	confess("_error() called with undefined \$format");
    }
    my @args = @_;

    if (!defined($self->{error}))
    {
	$self->{error} = "";
    }
    chomp($format);
    my $string = sprintf("GridShib-CA Configuration error: " . $format . "\n",
			 @args);
    $self->{error} .= $string;

    # Don't use our Logger module as that could create a deadlock as the
    # Logger class tries to load its configuration using this module
    # Instead we'll print to STDERR, which should end up in the web
    # server error logs.
    printf(STDERR $string);
}

=back

=head2 Version

GridShib-CA version @PACKAGE_VERSION_STRING@ ($Id$)

=cut

# Return true for import/use
1;

### Local Variables: ***
### mode:perl ***
### End: ***
######################################################################
