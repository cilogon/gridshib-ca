######################################################################
#
# This file is part of the GriShib-CA distribution.  Copyright
# 2006-2009 The Board of Trustees of the University of
# Illinois. Please see LICENSE at the root of the distribution.
#
######################################################################

=head1 GridShibCA::WebCommand

Base class for Web Commands to be invoked by CGI scripts.

=cut

package GridShibCA::WebCommand;

use Carp;
use GridShibCA::CGISession;  # For exceptions
use GridShibCA::Config;
use GridShibCA::ErrorHandler qw(handleError);
use GridShibCA::Exception qw(:try);

=head2 Constants

The following are flags which are OR'ed together and used by
_requirements().

=over 4

=item $REQUIRE_NOTHING

=cut

$REQUIRE_NOTHING = 0x0000;

=item $REQUIRE_HTTPS

Require HTTPS as opposed to HTTP.

=cut

$REQUIRE_HTTPS = 0x0001;

=item $REQUIRE_SESSION

Require an established session.

=cut

$REQUIRE_SESSION = 0x0002;

=item $ACCEPT_SESSION

Process a session if presented, but do not require it. WebCommand
implementation is responsible for checking for established session.

=cut

$ACCEPT_SESSION = 0x0004;

=item $REQUIRE_CSRF_CHECK

Require CSRF protection.

=cut

$REQUIRE_CSRF_CHECK = 0x0008;

=item Require POST (as opposed to GET or HEAD)

=cut

$REQUIRE_POST = 0x0010;

=back

=head2 Methods

=over 4

=item new()

Create a new WebCommand object.

B<Arguments:> Hash, currently ignored.

B<Returns:> WebCommand instance. Throws GridShibCA::Exception on error.

=cut

sub new
{
    my $class = shift;
    my %args = @_;
    my $self = {};
    bless($self, $class);
    $self->{config} = GridShibCA::Config->new();
    $self->{logger} = $self->{config}->getLogger();
    $self->{cgi} = $self->{config}->getCGI();
    # Cookies to be added to output HTML
    $self->{cookies} = [];
    return $self;
}


=item invoke()

Process a request from the client. Should be called by
WebApp.pm::invokeCommand()

B<Arguments:> None

B<Returns:> Nothing

=cut

sub invoke
{
    my $self = shift;

    try
    {
	$self->{logger}->info("Invoking %s module.", ref($self));
	$self->_handleRequirements();
    }
    catch GridShibCA::SessionExpiredException with
    {
	my $ex = shift;
	$ex->flush();
	$self->_handleExpiredSession();
    }
    catch GridShibCA::SessionException with
    {
	my $ex = shift;
	$ex->flush();
	$self->_handleMissingSession();
    }
    otherwise
    {
	my $ex = shift;
	handleError("Error with request: " . $ex->text(),
	    -exception=>$ex);
    };

    # Any exception from this should be handled by WebApp.pm
    $self->doCommand();
}

=item doCommand()

This method should be overridden by the child class and implement the
actual work of the module.

B<Arguments:> None

B<Returns:> 1 on success, 0 on error.

May throw exceptions of any sort.

=cut

sub doCommand
{
    my $self = shift;

    return 1;
}

=back

=cut

######################################################################

=head2 Internal methods

These internal methods not intended for external use.

=over 4

=item _handleExpiredSession

Handle situation when session is required but has expired.
Displays SessionExpired template.

B<Arguments:> None

B<Returns:> Doesn't

=cut

sub _handleExpiredSession
{
    my $self = shift;

    $self->{logger}->debug("Handling expired session");
    my $authnMethod = $self->{session}->param("AuthnMethod");
    my $authnURL = $self->{config}->getParam("AuthMethods", $authnMethod);
    $self->_displayHTML(
	"SessionExpired",
	AuthnMethod => $authnMethod,
	AuthnURL => $authnURL,
	"-status" => 401);
    $self->_exit();
}

=item _handleMissingSession

Handle situation when session is required but is missing.
Displays SessionMissing template.

B<Arguments:> None

B<Returns:> Doesn't

=cut

sub _handleMissingSession
{
    my $self = shift;

    $self->{logger}->debug("Handling missing session");
    my %signOnMethods = $self->{config}->getSection("AuthMethods");
    $self->_displayHTML(
	"SessionMissing",
	"SignOnMethods" => \%signOnMethods,
	"-status" => 401);
    $self->_exit();
}

=item _addCookie()

Add cookie to output HTML.

B<Arguments>: CGI::cookie() instance

B<Returns:> Nothing

=cut

sub _addCookie
{
    my $self = shift;
    my $cookie = shift ||
	throw GridShibCA::Exception("Missing cookie argument");
    my $cookies = $self->{cookies};
    push(@$cookies, $cookie);
}

=item _displayHTML()

Display HTML template with given name.

B<Arguments:>

C<$filename> Name of HTML template in gridshib-ca.conf Templates section.

C<%mappings> Mappings for subsitution.  Can include -status, which
will be used for the HTTP status of the response.

B<Returns:> True on success, False on error.

=cut

sub _displayHTML
{
    my $self = shift;
    my $templateName = shift;
    my %mappings = @_;

    my $template = $self->{config}->getHTMLTemplate($templateName);
    $template->setCookies($self->{cookies});
    if (defined($mappings{-status}))
    {
	$self->{logger}->debug("Setting response status to %s",
			       $mappings{-status});
	$template->setStatus($mappings{-status});
    }
    
    # Add some ubiquitous mappings
    $mappings{GridShibCAURL} = $self->{config}->getParamURL("URLs", "WebApp");
    $mappings{MyURL} = $self->{cgi}->url(-full => 1);

    $template->addMappings(%mappings);

    my $html = $template->getText();
    print $html;

    return 1;
}

=item _displayHTMLError()

Display HTML template with given name.

B<Arguments:>

C<$message> Error message. 

C<%mappings> Optional additional mappings for subsitution.  Can
include -status, which will be used for the HTTP status of the
response. If a status is not give, 501 is used.

B<Returns:> Nothing

=cut

sub _displayHTMLError
{
    my $self = shift;
    my $message = shift;
    my %mappings;
    if (scalar(@_) > 0)
    {
	%mappings = @_;
    }
    else
    {
	%mappings = ();
    }
    $mappings{Error} = $message;
    if (!defined($mappings{-status}))
    {
	$mappings{-status} = 501;
    }
    $self->_displayHTML("ErrorTemplate", %mappings);
}

=item _handleRequirements()

Handle the requirements, as returned by _getRequirements(), of this
command.

B<arguments:> None

B<Returns:> Nothing, throws exception on error.

=cut
sub _handleRequirements
{
    my $self = shift;

    my $requirements = $self->_requirements();
    if (!defined($requirements))
    {
	throw GridShibCA::RequirementsException("Requirements undefined.");
    }
    $self->{logger}->debug("Checking request requirements (0x%X)",
			   $requirements);

    if ($requirements & $REQUIRE_HTTPS)
    {
	if ($self->_checkHTTPS())
	{
	    $self->{logger}->debug("Verified HTTPS protection.");
	}
	else
	{
	    throw GridShibCA::RequirementsException(
		"Deployment error: HTTPS protection required but not provided");
	}
    }

    if ($requirements & $REQUIRE_SESSION)
    {
	try
	{
	    $self->{logger}->debug("Checking for required session.");
	    $self->{session} = $self->{config}->getCGISession();
	    $self->{session}->fromCGI($self->{cgi});
	}
	catch GridShibCA::SessionExpiredException with
	{
	    my $ex = shift;
	    $ex->throw();
	}
	catch GridShibCA::SessionException with
	{
	    my $ex = shift;
	    $ex->throw();
	}
	otherwise
	{
	    my $ex = shift;
	    $self->{logger}->logException($ex);
	    throw GridShibCA::RequirementsException(
		"Unexpected error establishing session: " . $ex->text());
	};
    }

    if ($requirements & $ACCEPT_SESSION)
    {
	try
	{
	    $self->{logger}->debug("Checking for optional session.");
	    $self->{session} = $self->{config}->getCGISession();
	    $self->{session}->fromCGI($self->{cgi});
	}
	catch GridShibCA::SessionExpiredException with
	{
	    # Ignore exception
	    my $ex = shift;
	    $ex->flush();
	}
	catch GridShibCA::SessionException with
	{
	    # Ignore exception
	    my $ex = shift;
	    $ex->flush();
	}
	otherwise
	{
	    my $ex = shift;
	    $self->{logger}->logException($ex);
	    throw GridShibCA::RequirementsException(
		"Unexpected error establishing session: " . $ex->text());
	};
    }

    if ($requirements & $REQUIRE_CSRF_CHECK)
    {
	$self->{logger}->debug("CSRF check");
	my $csrf = $self->{config}->getCSRF();
	$csrf->check();
    }

    if ($requirements & $REQUIRE_POST)
    {
	$self->{logger}->debug("Checking for POST");
	my $method = $self->{cgi}->request_method();
	if ($method ne "POST")
	{
	    throw GridShibCA::RequirementsException(
		"POST required but \"$method\" used.");
	}
    }
    $self->{logger}->debug("Requirements check done.");
}

=item _checkHTTPS

Check and make sure request is over https.

B<Arguments:> None

B<Returns:> 1 if over https, zero otherwise.

=cut

sub _checkHTTPS
{
    my $self = shift;

    my $result = 0;
    my $url = $self->{cgi}->url(-full=>1);
    if ($url =~ /^https:/)
    {
	$result = 1;
    }
    else
    {
	$result = 0;
	$self->{logger}->err("Check for HTTPS failed. URL is %s", $url);
    }

    return $result;
}

=item _redirect()

Redirect the user to the given URL.

B<Arguments:> URL as string

B<Returns:> Nothing

=cut

sub _redirect
{
    my $self = shift;
    my $url = shift ||
	throw GridShibCA::Exception("Missing url argument");
    print $self->{cgi}->redirect($url);
}

=item _exit()

Exit. Does nothing special, just here for future hook point.

B<Arguments:> Options status, zero is default.

B<Returns:> Doesn't.

=cut

sub _exit
{
    my $self = shift;
    my $status = shift || 0;
    $self->{logger}->debug("Exiting.");
    exit($status);
}

=item _requirements()

Return the requirements of the command, which should be an bitwise OR
of the REQUIRE_* and ACCEPT_* constants.  This method should be
overridden by the child class.

B<Arguments:> None

B<Returns:> Requirements value

=cut

sub _requirements
{
    return $GridShibCA::WebCommand::REQUIRE_NOTHING;
}

=back

=cut

######################################################################

package GridShibCA::RequirementsException;

# Inherit GridShibCA::Exception
use base qw(GridShibCA::Exception);

=head1 GridShibCA::RequirementsException

Class for exceptions caused by requirement errors.

=cut

######################################################################

=head2 Version

GridShib-CA version @PACKAGE_VERSION_STRING@ ($Id$)

=cut

# Return true for import/use
1;

######################################################################
### Local Variables: ***
### mode:perl ***
### End: ***
