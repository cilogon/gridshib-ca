#!@PERL@ @PERL_ARGS@
######################################################################
#
# $Id$
#
# Base class for Web Commands.
#
######################################################################
# Copyright 2006 The Board of Trustees of the University of Illinois.
# All rights reserved.

# Developed by:

#   The GridShib Project
#   National Center for Supercomputing Applications
#   University of Illinois
#   http://gridshib.globus.org/

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal with the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

#   Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimers.

#   Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimers in the
#   documentation and/or other materials provided with the distribution.

#   Neither the names of the National Center for Supercomputing
#   Applications, the University of Illinois, nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this Software without specific prior written permission.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.
######################################################################

=head1 GridShibCA::WebCommand

Base class for Web Commands to be invoked by CGI scripts.

=cut

package GridShibCA::WebCommand;

use Carp;
use GridShibCA::CGISession;  # For exceptions
use GridShibCA::Config;
use GridShibCA::ErrorHandler qw(handleError);
use GridShibCA::Exception qw(:try);

=head2 Constants

The following are flags which are OR'ed together and used by
_requirements().

=over 4

=item $REQUIRE_NOTHING

=cut

$REQUIRE_NOTHING = 0x0000;

=item $REQUIRE_HTTPS

Require HTTPS as opposed to HTTP.

=cut

$REQUIRE_HTTPS = 0x0001;

=item $REQUIRE_SESSION

Require an established session.

=cut

$REQUIRE_SESSION = 0x0002;

=item $ACCEPT_SESSION

Process a session if presented, but do not require it. WebCommand
implementation is responsible for checking for established session.

=cut

$ACCEPT_SESSION = 0x0004;

=item $REQUIRE_CSRF_CHECK

Require CSRF protection.

=cut

$REQUIRE_CSRF_CHECK = 0x0008;

=back

=head2 Methods

=over 4

=item new()

Create a new WebCommand object.

B<Arguments:> None

B<Returns:> WebCommand instance. Throws GridShibCA::Exception on error.

=cut

sub new
{
    my $class = shift;
    my $self = {};
    bless($self, $class);
    $self->{config} = GridShibCA::Config->new();
    $self->{logger} = $self->{config}->getLogger();
    $self->{cgi} = $self->{config}->getCGI();
    # Cookies to be added to output HTML
    $self->{cookies} = [];
    return $self;
}


=item invoke()

Process a request from the client. Should be called by
WebApp.pm::invokeCommand()

B<Arguments:> None

B<Returns:> Nothing

=cut

sub invoke
{
    my $self = shift;

    try
    {
	$self->{logger}->info("Invoking %s module.", ref($self));
	$self->_handleRequirements();
    }
    otherwise
    {
	my $ex = shift;
	handleError("Error with request: " . $ex->text(),
	    -exception=>$ex);
    };

    # Any exception from this should be handled by WebApp.pm
    $self->doCommand();
}

=item doCommand()

This method should be overridden by the child class and implement the
actual work of the module.

B<Arguments:> None

B<Returns:> 1 on success, 0 on error.

May throw exceptions of any sort.

=cut

sub doCommand
{
    my $self = shift;

    return 1;
}

=back

=cut

######################################################################

=head2 Internal methods

These internal methods not intended for external use.

=over 4

=item _addCookie()

Add cookie to output HTML.

B<Arguments>: CGI::cookie() instance

B<Returns:> Nothing

=cut

sub _addCookie
{
    my $self = shift;
    my $cookie = shift ||
	throw GridShibCA::Exception("Missing cookie argument");
    my $cookies = $self->{cookies};
    push(@$cookies, $cookie);
}

=item _displayHTML()

Display HTML template with given name.

B<Arguments:>

C<$filename> Name of HTML template in gridshib-ca.conf Templates section.

C<%mappings> Mappings for subsitution

B<Returns:> True on success, False on error.

=cut

sub _displayHTML
{
    my $self = shift;
    my $templateName = shift;
    my %mappings = @_;

    my $template = $self->{config}->getHTMLTemplate($templateName);
    $template->setCookies($self->{cookies});

    # Add some ubiquitous mappings
    $mappings{GridShibCAURL} = $self->{config}->getParamURL("URLs", "WebApp");
    $mappings{MyURL} = $self->{cgi}->url(-full => 1);

    $template->addMappings(%mappings);

    my $html = $template->getText();
    print $html;

    return 1;
}

=item _displayHTMLError()

Display HTML template with given name.

B<Arguments:>

C<$message> Error message

C<%mappings> Optional additional mappings for subsitution

B<Returns:> Nothing

=cut

sub _displayHTMLError
{
    my $self = shift;
    my $message = shift;
    my %mappings;
    if (scalar(@_) > 0)
    {
	%mappings = @_;
    }
    else
    {
	%mappings = ();
    }
    $mappings{Error} = $message;
    $self->_displayHTML("ErrorTemplate", %mappings);
}

=item _handleRequirements()

Handle the requirements, as returned by _getRequirements(), of this
command.

B<arguments:> None

B<Returns:> Nothing. 

Throws GridShibCA::RequirementsException on Error.

=cut
sub _handleRequirements
{
    my $self = shift;

    my $requirements = $self->_requirements();
    if (!defined($requirements))
    {
	throw GridShibCA::RequirementsException("Requirements undefined.");
    }
    $self->{logger}->debug("Checking request requirements (0x%X)",
			   $requirements);

    if ($requirements & $REQUIRE_HTTPS)
    {
	if ($self->_checkHTTPS())
	{
	    $self->{logger}->debug("Verified HTTPS protection.");
	}
	else
	{
	    throw GridShibCA::RequirementsException(
		"Deployment error: HTTPS protection required but not provided");
	}
    }

    if ($requirements & $REQUIRE_SESSION)
    {
	try
	{
	    $self->{session} = $self->{config}->getCGISession();
	    $self->{session}->fromCGI($self->{cgi});
	}
	catch GridShibCA::SessionExpiredException with
	{
	    # XXX should redirect to login.cgi here
	    my $ex = shift;
	    $self->{logger}->logException($ex);
	    throw GridShibCA::RequirementsException(
		"Session expired.");
	}
	catch GridShibCA::SessionException with
	{
	    # XXX Should redirect use to login.cgi here
	    my $ex = shift;
	    $self->{logger}->logException($ex);
	    throw GridShibCA::RequirementsException(
		"Failed to establish session.");
	}
	otherwise
	{
	    my $ex = shift;
	    $self->{logger}->logException($ex);
	    throw GridShibCA::RequirementsException(
		"Unexpected error establishing session: " . $ex->text());
	};
    }

    if ($requirements & $ACCEPT_SESSION)
    {
	try
	{
	    $self->{logger}->debug("Checking for optional session.");
	    $self->{session} = $self->{config}->getCGISession();
	    $self->{session}->fromCGI($self->{cgi});
	    $self->{logger}->debug("Session accepted: %s",
		$self->{session}->id());
	}
	catch GridShibCA::SessionExpiredException with
	{
	    # Ignore exception
	    my $ex = shift;
	    $ex->flush();
	}
	catch GridShibCA::SessionException with
	{
	    # Ignore exception
	    my $ex = shift;
	    $ex->flush();
	}
	otherwise
	{
	    my $ex = shift;
	    $self->{logger}->logException($ex);
	    throw GridShibCA::RequirementsException(
		"Unexpected error establishing session: " . $ex->text());
	};
    }

    if ($requirements & $REQUIRE_CSRF_CHECK)
    {
	throw GridShibCA::RequirementsException(
	    "CSRF protection not implemented yet.");
    }
    $self->{logger}->debug("Requirements check done.");
}

=item _checkHTTPS

Check and make sure request is over https.

B<Arguments:> None

B<Returns:> 1 if over https, zero otherwise.

=cut

sub _checkHTTPS
{
    my $self = shift;

    my $result = 0;
    my $url = $self->{cgi}->url(-full=>1);
    if ($url =~ /^https:/)
    {
	$result = 1;
    }
    else
    {
	$result = 0;
	$self->{logger}->err("Check for HTTPS failed. URL is %s", $url);
    }

    return $result;
}

=item _redirect()

Redirect the user to the given URL.

B<Arguments:> URL as string

B<Returns:> Nothing

=cut

sub _redirect
{
    my $self = shift;
    my $url = shift ||
	throw GridShibCA::Exception("Missing url argument");
    print $self->{cgi}->redirect($url);
}

=item _requirements()

Return the requirements of the command, which should be an bitwise OR
of the REQUIRE_* and ACCEPT_* constants.  This method should be
overridden by the child class.

B<Arguments:> None

B<Returns:> Requirements value

=cut

sub _requirements
{
    return $GridShibCA::WebCommand::REQUIRE_NOTHING;
}

=back

=cut

######################################################################

package GridShibCA::RequirementsException;

# Inherit GridShibCA::Exception
use base qw(GridShibCA::Exception);

=head1 GridShibCA::RequirementsException

Class for exceptions caused by requirement errors.

=cut

######################################################################

=head2 Version

GridShib-CA version @PACKAGE_VERSION_STRING@ ($Id$)

=cut

# Return true for import/use
1;

######################################################################
### Local Variables: ***
### mode:perl ***
### End: ***
